digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 204"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-125"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 section_6 section_7 section_8 section_9}
{rank=same; header_2 prose_3 prose_4 prose_5 section_6 section_7 section_8 section_9}

header_2 [label="1 : Deck"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

section_6 [label="section: 15-36"]

section_7 [label="section: 37-90"]

section_8 [label="section: 91-125"]

section_9 [label="section: 126-173"]


// END RANK section_1

header_2 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Deck"]
// END RANK header_2

prose_3 -> { raw_11}
{rank=same; raw_11}

raw_11 [label="raw"]


// END RANK prose_3

raw_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


A Deck is a way of corresponding the various incarnations of a source file
on a per-directory basis.
"]
// END RANK raw_11

prose_4 -> { raw_13}
{rank=same; raw_13}

raw_13 [label="raw"]


// END RANK prose_4

raw_13 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is currently limited to Orb and sorcery files, but will also include
weaves and bytecode (bytecode I'm working on at present).
"]
// END RANK raw_13

prose_5 -> { raw_15}
{rank=same; raw_15}

raw_15 [label="raw"]


// END RANK prose_5

raw_15 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The reason weaves haven't been incorporated is simply that weaving has never
been updated to use the new abstractions, and as I intend to (mostly) replace
translation to Markdown with translation to HTML, this is fine for now.

"]
// END RANK raw_15

section_6 -> { header_17 prose_18 prose_19 prose_20 prose_21}
{rank=same; header_17 prose_18 prose_19 prose_20 prose_21}

header_17 [label="4 : a digression on literate programming and file correspondence"]

prose_18 [label="prose"]

prose_19 [label="prose"]

prose_20 [label="prose"]

prose_21 [label="prose"]


// END RANK section_6

header_17 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** a digression on literate programming and file correspondence"]
// END RANK header_17

prose_18 -> { raw_23 prespace_24 italic_25 raw_26}
{rank=same; raw_23 prespace_24 italic_25 raw_26}

raw_23 [label="raw"]

prespace_24 [label="prespace"]

italic_25 [label="italic"]

raw_26 [label="raw"]


// END RANK prose_18

raw_23 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  At some later point in the evolution of this tool, I intend to break the
one-to-one correspondence of Orb files with sorcery.  This is one of the
promising aspects of literate programming, but to achieve this in a way which
is"]
// END RANK raw_23

prespace_24 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_24

italic_25 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="useful to the programmer"]
// END RANK italic_25

raw_26 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" I will have to make considerable progress on the
rest of the tools.
"]
// END RANK raw_26

prose_19 -> { raw_31}
{rank=same; raw_31}

raw_31 [label="raw"]


// END RANK prose_19

raw_31 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The bare minimum I'll need here will be source mapping, so that the runtime
may present to the user a correspondence between an error message and the
actual source code, which is, let us remember, the Orb files.
"]
// END RANK raw_31

prose_20 -> { raw_33}
{rank=same; raw_33}

raw_33 [label="raw"]


// END RANK prose_20

raw_33 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is one of the reasons, in my opinion, that literate programming never
caught on.  It is liberating to be able to use macros and the like to write
the code in a reader's expected order, but tedious and taxing to have to
figure out where an error is to be found in the actual code.
"]
// END RANK raw_33

prose_21 -> { raw_35}
{rank=same; raw_35}

raw_35 [label="raw"]


// END RANK prose_21

raw_35 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This taxation comes at the worst possible time, when all of the writer's
energy is being channeled into debugging.  I've been known to lose my train of
thought just between seeing an error line and tabbing over to my editor.

"]
// END RANK raw_35

section_7 -> { header_37 prose_38 prose_39 prose_40 prose_41 prose_42 prose_43 prose_44 codeblock_45 codeblock_46 codeblock_47}
{rank=same; header_37 prose_38 prose_39 prose_40 prose_41 prose_42 prose_43 prose_44 codeblock_45 codeblock_46 codeblock_47}

header_37 [label="2 : Instance fields."]

prose_38 [label="prose"]

prose_39 [label="prose"]

prose_40 [label="prose"]

prose_41 [label="prose"]

prose_42 [label="prose"]

prose_43 [label="prose"]

prose_44 [label="prose"]

codeblock_45 [label="code block 57-68"]

codeblock_46 [label="code block 70-74"]

codeblock_47 [label="code block 76-88"]


// END RANK section_7

header_37 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Instance fields."]
// END RANK header_37

prose_38 -> { raw_49}
{rank=same; raw_49}

raw_49 [label="raw"]


// END RANK prose_38

raw_49 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Decks have sub decks, if any, in the array portion of their table.
"]
// END RANK raw_49

prose_39 -> { raw_51}
{rank=same; raw_51}

raw_51 [label="raw"]


// END RANK prose_39

raw_51 -> leaf_52
leaf_52  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- dir:  A Directory object corresponding to the Deck.
"]
// END RANK raw_51

prose_40 -> { raw_53}
{rank=same; raw_53}

raw_53 [label="raw"]


// END RANK prose_40

raw_53 -> leaf_54
leaf_54  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- codex: The Codex of which this directory is a part. A given Deck must be
         created with a Codex.
"]
// END RANK raw_53

prose_41 -> { raw_55}
{rank=same; raw_55}

raw_55 [label="raw"]


// END RANK prose_41

raw_55 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- docs:  A map, the keys of which are full path names, and the values of which
         are Doc objects.
"]
// END RANK raw_55

prose_42 -> { raw_57}
{rank=same; raw_57}

raw_57 [label="raw"]


// END RANK prose_42

raw_57 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- srcs:  A map, keys are full path names, values are knit sorcery files.
"]
// END RANK raw_57

prose_43 -> { raw_59 prespace_60 literal_61 raw_62 prespace_63 literal_64 raw_65}
{rank=same; raw_59 prespace_60 literal_61 raw_62 prespace_63 literal_64 raw_65}

raw_59 [label="raw"]

prespace_60 [label="prespace"]

literal_61 [label="literal"]

raw_62 [label="raw"]

prespace_63 [label="prespace"]

literal_64 [label="literal"]

raw_65 [label="raw"]


// END RANK prose_43

raw_59 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- eponym:  A Doc which has"]
// END RANK raw_59

prespace_60 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_60

literal_61 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label="{basename}.org"]
// END RANK literal_61

raw_62 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", that is, the basename of the
           deck, will be added to"]
// END RANK raw_62

prespace_63 -> leaf_70
leaf_70  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_63

literal_64 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="deck.eponym"]
// END RANK literal_64

raw_65 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_65

prose_44 -> { raw_73}
{rank=same; raw_73}

raw_73 [label="raw"]


// END RANK prose_44

raw_73 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
           I don't appear to use this, at present.  But it's harmless, at
           least.
"]
// END RANK raw_73

codeblock_45 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local s   = require \"status\" ()
s.verbose = false
s.chatty  = true

local c   = require \"singletons/color\"
local cAlert = c.color.alert

local Dir = require \"walk/directory\"
local Doc = require \"Orbit/doc\"
local Node = require \"espalier/node\""]
// END RANK codeblock_45

codeblock_46 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Deck = {}
Deck.__index = Deck
local __Decks = {}"]
// END RANK codeblock_46

codeblock_47 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- ignore a few critters that can show up
local decIgnore = {\".DS_Store\", \".git\", \".orbback\"}

local function ignore(file)
   local willIgnore = false
   local basename = file:basename()
   for _, str in ipairs(decIgnore) do
      willIgnore = willIgnore or basename == str
   end
   return willIgnore
end"]
// END RANK codeblock_47

section_8 -> { header_78 prose_79 prose_80 codeblock_81}
{rank=same; header_78 prose_79 prose_80 codeblock_81}

header_78 [label="2 : spin(deck)"]

prose_79 [label="prose"]

prose_80 [label="prose"]

codeblock_81 [label="code block 97-123"]


// END RANK section_8

header_78 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** spin(deck)"]
// END RANK header_78

prose_79 -> { raw_83}
{rank=same; raw_83}

raw_83 [label="raw"]


// END RANK prose_79

raw_83 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

If we're going to be lazy, this is where we should do it!
"]
// END RANK raw_83

prose_80 -> { raw_85}
{rank=same; raw_85}

raw_85 [label="raw"]


// END RANK prose_80

raw_85 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Right now, we're going to load all Docs into memory, willy nilly.
"]
// END RANK raw_85

codeblock_81 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function spin(deck)
   local err = {}
   local dir = deck.dir
   local codex = deck.codex
   for _, subdeck in ipairs(deck) do
      spin(subdeck)
   end
   local files = dir:getfiles()
   for _, file in ipairs(files) do
      if not ignore(file) then
         local doc = Doc(file:read())
         if doc.id and doc.id == \"doc\" then
            deck.docs[file.path.str] = doc
            codex.docs[file.path.str] = doc
            codex.files[file.path.str] = file
         else
            s:complain(\"no doc\",
                       tostring(file) .. \" doesn't generate a doc\")
         end
      end
   end
   return deck, err
end

Deck.spin = spin"]
// END RANK codeblock_81

section_9 -> { header_88 prose_89 prose_90 prose_91 codeblock_92 section_93}
{rank=same; header_88 prose_89 prose_90 prose_91 codeblock_92 section_93}

header_88 [label="2 : case(deck)"]

prose_89 [label="prose"]

prose_90 [label="prose"]

prose_91 [label="prose"]

codeblock_92 [label="code block 137-172"]

section_93 [label="section: 174-204"]


// END RANK section_9

header_88 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** case(deck)"]
// END RANK header_88

prose_89 -> { raw_95}
{rank=same; raw_95}

raw_95 [label="raw"]


// END RANK prose_89

raw_95 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Casing is what we call gathering information about a deck, its subdecks,
and associated files.
"]
// END RANK raw_95

prose_90 -> { raw_97}
{rank=same; raw_97}

raw_97 [label="raw"]


// END RANK prose_90

raw_97 -> leaf_98
leaf_98  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Casing a deck will cause its subdecks to be cased also, recursively. This is
where we will add inode comparison to keep from following cyclic references,
since it's what draws directory attributes out of the filesystem into memory.
"]
// END RANK raw_97

prose_91 -> { raw_99 link_100 raw_101}
{rank=same; raw_99 link_100 raw_101}

raw_99 [label="raw"]

link_100 [label="link"]

raw_101 [label="raw"]


// END RANK prose_91

raw_99 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
After casing a Deck is ready to be "]
// END RANK raw_99

link_100 -> { anchortext_103 url_104}
{rank=same; anchortext_103 url_104}

anchortext_103 [label="anchortext"]

url_104 [label="url"]


// END RANK link_100

anchortext_103 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label="spun"]
// END RANK anchortext_103

url_104 -> leaf_106
leaf_106  [color=Gray,shape=rectangle,fontname=Inconsolata,label="httk://"]
// END RANK url_104

raw_101 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_101

codeblock_92 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local new

function Deck.case(deck)
   s:verb(\"dir: \" .. tostring(deck.dir))
   local dir = deck.dir
   local codex = deck.codex
   local basename = dir:basename()
   assert(dir.idEst == Dir, \"dir not a directory\")
   local codexRoot = codex.root:basename()
   s:verb(\"root: \" .. tostring(codex.root) .. \" base: \" ..tostring(codexRoot))
   local subdirs = dir:getsubdirs()
   s:verb(\"  \" .. \"# subdirs: \" .. #subdirs)
   for i, sub in ipairs(subdirs) do
      s:verb(\"  - \" .. sub.path.str)
      deck[i] = new(codex, sub)
   end
   local files = dir:getfiles()
   s:verb(\"  \" .. \"# files: \" .. #files)
   for i, file in ipairs(files) do
      if not ignore(file) then
         local name = file:basename()
         if #file:extension() > 1 then
            name = string.sub(name, 1, - #file:extension() - 1)
         end
         if name == basename then
            s:verb(\"  ~ \" .. name)
            deck.eponym = file
         end
      end
   end

   s:verb(\"#deck is : \" .. #deck)
   return codex
end"]
// END RANK codeblock_92

section_93 -> { header_109 prose_110 codeblock_111 codeblock_112 codeblock_113}
{rank=same; header_109 prose_110 codeblock_111 codeblock_112 codeblock_113}

header_109 [label="3 : __tostring"]

prose_110 [label="prose"]

codeblock_111 [label="code block 176-180"]

codeblock_112 [label="code block 182-198"]

codeblock_113 [label="code block 201-204"]


// END RANK section_93

header_109 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** __tostring"]
// END RANK header_109

prose_110 -> { raw_115}
{rank=same; raw_115}

raw_115 [label="raw"]


// END RANK prose_110

raw_115 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_115

codeblock_111 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Deck.__tostring(deck)
   return deck.dir.path.str
end"]
// END RANK codeblock_111

codeblock_112 -> leaf_118
leaf_118  [color=Gray,shape=rectangle,fontname=Inconsolata,label="new = function (codex, dir)
   if type(dir) == \"string\" then
      dir = Dir(dir)
   end
   if __Decks[dir] then
      return __Decks[dir]
   end
   local deck = setmetatable({}, Deck)
   deck.dir = dir
   deck.codex = codex
   deck.docs  = {}
   deck.srcs  = {}
   Deck.case(deck)
   return deck
end"]
// END RANK codeblock_112

codeblock_113 -> leaf_119
leaf_119  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Deck.idEst = new
return new"]
// END RANK codeblock_113


}
