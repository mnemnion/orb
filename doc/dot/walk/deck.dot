digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 218"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-135"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 section_6 section_7 section_8 section_9}
{rank=same; header_2 prose_3 prose_4 prose_5 section_6 section_7 section_8 section_9}

header_2 [label="1 : Deck"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

section_6 [label="section: 15-36"]

section_7 [label="section: 37-100"]

section_8 [label="section: 101-135"]

section_9 [label="section: 136-183"]


// END RANK section_1

header_2 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Deck"]
// END RANK header_2

prose_3 -> { raw_11}
{rank=same; raw_11}

raw_11 [label="raw"]


// END RANK prose_3

raw_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


A Deck is a way of corresponding the various incarnations of a source file
on a per-directory basis.
"]
// END RANK raw_11

prose_4 -> { raw_13}
{rank=same; raw_13}

raw_13 [label="raw"]


// END RANK prose_4

raw_13 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is currently limited to Orb and sorcery files, but will also include
weaves and bytecode (bytecode I'm working on at present).
"]
// END RANK raw_13

prose_5 -> { raw_15}
{rank=same; raw_15}

raw_15 [label="raw"]


// END RANK prose_5

raw_15 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The reason weaves haven't been incorporated is simply that weaving has never
been updated to use the new abstractions, and as I intend to (mostly) replace
translation to Markdown with translation to HTML, this is fine for now.

"]
// END RANK raw_15

section_6 -> { header_17 prose_18 prose_19 prose_20 prose_21}
{rank=same; header_17 prose_18 prose_19 prose_20 prose_21}

header_17 [label="4 : a digression on literate programming and file correspondence"]

prose_18 [label="prose"]

prose_19 [label="prose"]

prose_20 [label="prose"]

prose_21 [label="prose"]


// END RANK section_6

header_17 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** a digression on literate programming and file correspondence"]
// END RANK header_17

prose_18 -> { raw_23 prespace_24 italic_25 raw_26}
{rank=same; raw_23 prespace_24 italic_25 raw_26}

raw_23 [label="raw"]

prespace_24 [label="prespace"]

italic_25 [label="italic"]

raw_26 [label="raw"]


// END RANK prose_18

raw_23 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  At some later point in the evolution of this tool, I intend to break the
one-to-one correspondence of Orb files with sorcery.  This is one of the
promising aspects of literate programming, but to achieve this in a way which
is"]
// END RANK raw_23

prespace_24 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_24

italic_25 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="useful to the programmer"]
// END RANK italic_25

raw_26 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" I will have to make considerable progress on the
rest of the tools.
"]
// END RANK raw_26

prose_19 -> { raw_31}
{rank=same; raw_31}

raw_31 [label="raw"]


// END RANK prose_19

raw_31 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The bare minimum I'll need here will be source mapping, so that the runtime
may present to the user a correspondence between an error message and the
actual source code, which is, let us remember, the Orb files.
"]
// END RANK raw_31

prose_20 -> { raw_33}
{rank=same; raw_33}

raw_33 [label="raw"]


// END RANK prose_20

raw_33 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is one of the reasons, in my opinion, that literate programming never
caught on.  It is liberating to be able to use macros and the like to write
the code in a reader's expected order, but tedious and taxing to have to
figure out where an error is to be found in the actual code.
"]
// END RANK raw_33

prose_21 -> { raw_35}
{rank=same; raw_35}

raw_35 [label="raw"]


// END RANK prose_21

raw_35 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This taxation comes at the worst possible time, when all of the writer's
energy is being channeled into debugging.  I've been known to lose my train of
thought just between seeing an error line and tabbing over to my editor.

"]
// END RANK raw_35

section_7 -> { header_37 prose_38 prose_39 prose_40 prose_41 prose_42 prose_43 prose_44 prose_45 prose_46 prose_47 codeblock_48 codeblock_49 codeblock_50}
{rank=same; header_37 prose_38 prose_39 prose_40 prose_41 prose_42 prose_43 prose_44 prose_45 prose_46 prose_47 codeblock_48 codeblock_49 codeblock_50}

header_37 [label="2 : Instance fields."]

prose_38 [label="prose"]

prose_39 [label="prose"]

prose_40 [label="prose"]

prose_41 [label="prose"]

prose_42 [label="prose"]

prose_43 [label="prose"]

prose_44 [label="prose"]

prose_45 [label="prose"]

prose_46 [label="prose"]

prose_47 [label="prose"]

codeblock_48 [label="code block 65-76"]

codeblock_49 [label="code block 78-82"]

codeblock_50 [label="code block 84-98"]


// END RANK section_7

header_37 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Instance fields."]
// END RANK header_37

prose_38 -> { raw_52}
{rank=same; raw_52}

raw_52 [label="raw"]


// END RANK prose_38

raw_52 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Decks have sub decks, if any, in the array portion of their table.
"]
// END RANK raw_52

prose_39 -> { raw_54}
{rank=same; raw_54}

raw_54 [label="raw"]


// END RANK prose_39

raw_54 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- dir:  A Directory object corresponding to the Deck.
"]
// END RANK raw_54

prose_40 -> { raw_56}
{rank=same; raw_56}

raw_56 [label="raw"]


// END RANK prose_40

raw_56 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- codex: The Codex of which this directory is a part. A given Deck must be
         created with a Codex.
"]
// END RANK raw_56

prose_41 -> { raw_58}
{rank=same; raw_58}

raw_58 [label="raw"]


// END RANK prose_41

raw_58 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- docs:  A map, the keys of which are full path names, and the values of which
         are Doc objects.
"]
// END RANK raw_58

prose_42 -> { raw_60}
{rank=same; raw_60}

raw_60 [label="raw"]


// END RANK prose_42

raw_60 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- srcs:  A map, keys are full path names, values are knit sorcery files.
"]
// END RANK raw_60

prose_43 -> { raw_62}
{rank=same; raw_62}

raw_62 [label="raw"]


// END RANK prose_43

raw_62 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- docMds :  A map, the keys of which are full path names, and the values of
            which are a stringulated Markdown weave of the corresponding
            document.
"]
// END RANK raw_62

prose_44 -> { raw_64}
{rank=same; raw_64}

raw_64 [label="raw"]


// END RANK prose_44

raw_64 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- docDots :  A map of paths to dot files.
"]
// END RANK raw_64

prose_45 -> { raw_66}
{rank=same; raw_66}

raw_66 [label="raw"]


// END RANK prose_45

raw_66 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- docSvgs :  A map of paths to .svg files.
"]
// END RANK raw_66

prose_46 -> { raw_68 prespace_69 literal_70 raw_71 prespace_72 literal_73 raw_74}
{rank=same; raw_68 prespace_69 literal_70 raw_71 prespace_72 literal_73 raw_74}

raw_68 [label="raw"]

prespace_69 [label="prespace"]

literal_70 [label="literal"]

raw_71 [label="raw"]

prespace_72 [label="prespace"]

literal_73 [label="literal"]

raw_74 [label="raw"]


// END RANK prose_46

raw_68 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- eponym:  A Doc which has"]
// END RANK raw_68

prespace_69 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_69

literal_70 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="{basename}.org"]
// END RANK literal_70

raw_71 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", that is, the basename of the
           deck, will be added to"]
// END RANK raw_71

prespace_72 -> leaf_79
leaf_79  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_72

literal_73 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label="deck.eponym"]
// END RANK literal_73

raw_74 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_74

prose_47 -> { raw_82}
{rank=same; raw_82}

raw_82 [label="raw"]


// END RANK prose_47

raw_82 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
           I don't appear to use this, at present.  But it's harmless, at
           least.
"]
// END RANK raw_82

codeblock_48 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local s   = require \"status\" ()
s.verbose = false
s.chatty  = true

local c   = require \"singletons/color\"
local cAlert = c.color.alert

local Dir = require \"walk/directory\"
local Doc = require \"Orbit/doc\"
local Node = require \"espalier/node\""]
// END RANK codeblock_48

codeblock_49 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Deck = {}
Deck.__index = Deck
local __Decks = {}"]
// END RANK codeblock_49

codeblock_50 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- ignore a few critters that can show up
local decIgnore = {\".DS_Store\", \".git\", \".orbback\"}

local function ignore(file)
   local willIgnore = false
   local basename = file:basename()
   for _, str in ipairs(decIgnore) do
      willIgnore = willIgnore or basename == str
   end
   -- Goddammit Dropbox
   willIgnore = willIgnore or (string.find(tostring(file), \"%.%_\") ~= nil)
   return willIgnore
end"]
// END RANK codeblock_50

section_8 -> { header_87 prose_88 prose_89 codeblock_90}
{rank=same; header_87 prose_88 prose_89 codeblock_90}

header_87 [label="2 : spin(deck)"]

prose_88 [label="prose"]

prose_89 [label="prose"]

codeblock_90 [label="code block 107-133"]


// END RANK section_8

header_87 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** spin(deck)"]
// END RANK header_87

prose_88 -> { raw_92}
{rank=same; raw_92}

raw_92 [label="raw"]


// END RANK prose_88

raw_92 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

If we're going to be lazy, this is where we should do it!
"]
// END RANK raw_92

prose_89 -> { raw_94}
{rank=same; raw_94}

raw_94 [label="raw"]


// END RANK prose_89

raw_94 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Right now, we're going to load all Docs into memory, willy nilly.
"]
// END RANK raw_94

codeblock_90 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function spin(deck)
   local err = {}
   local dir = deck.dir
   local codex = deck.codex
   for _, subdeck in ipairs(deck) do
      spin(subdeck)
   end
   local files = dir:getfiles()
   for _, file in ipairs(files) do
      if not ignore(file) then
         local doc = Doc(file:read())
         if doc.id and doc.id == \"doc\" then
            deck.docs[file.path.str] = doc
            codex.docs[file.path.str] = doc
            codex.files[file.path.str] = file
         else
            s:complain(\"no doc\",
                       tostring(file) .. \" doesn't generate a doc\")
         end
      end
   end
   return deck, err
end

Deck.spin = spin"]
// END RANK codeblock_90

section_9 -> { header_97 prose_98 prose_99 prose_100 codeblock_101 section_102}
{rank=same; header_97 prose_98 prose_99 prose_100 codeblock_101 section_102}

header_97 [label="2 : case(deck)"]

prose_98 [label="prose"]

prose_99 [label="prose"]

prose_100 [label="prose"]

codeblock_101 [label="code block 147-182"]

section_102 [label="section: 184-218"]


// END RANK section_9

header_97 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** case(deck)"]
// END RANK header_97

prose_98 -> { raw_104}
{rank=same; raw_104}

raw_104 [label="raw"]


// END RANK prose_98

raw_104 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  Casing is what we call gathering information about a deck, its subdecks,
and associated files.
"]
// END RANK raw_104

prose_99 -> { raw_106}
{rank=same; raw_106}

raw_106 [label="raw"]


// END RANK prose_99

raw_106 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Casing a deck will cause its subdecks to be cased also, recursively. This is
where we will add inode comparison to keep from following cyclic references,
since it's what draws directory attributes out of the filesystem into memory.
"]
// END RANK raw_106

prose_100 -> { raw_108 link_109 raw_110}
{rank=same; raw_108 link_109 raw_110}

raw_108 [label="raw"]

link_109 [label="link"]

raw_110 [label="raw"]


// END RANK prose_100

raw_108 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
After casing a Deck is ready to be "]
// END RANK raw_108

link_109 -> { anchortext_112 url_113}
{rank=same; anchortext_112 url_113}

anchortext_112 [label="anchortext"]

url_113 [label="url"]


// END RANK link_109

anchortext_112 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label="spun"]
// END RANK anchortext_112

url_113 -> leaf_115
leaf_115  [color=Gray,shape=rectangle,fontname=Inconsolata,label="httk://"]
// END RANK url_113

raw_110 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_110

codeblock_101 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local new

function Deck.case(deck)
   s:verb(\"dir: \" .. tostring(deck.dir))
   local dir = deck.dir
   local codex = deck.codex
   local basename = dir:basename()
   assert(dir.idEst == Dir, \"dir not a directory\")
   local codexRoot = codex.root:basename()
   s:verb(\"root: \" .. tostring(codex.root) .. \" base: \" ..tostring(codexRoot))
   local subdirs = dir:getsubdirs()
   s:verb(\"  \" .. \"# subdirs: \" .. #subdirs)
   for i, sub in ipairs(subdirs) do
      s:verb(\"  - \" .. sub.path.str)
      deck[i] = new(codex, sub)
   end
   local files = dir:getfiles()
   s:verb(\"  \" .. \"# files: \" .. #files)
   for i, file in ipairs(files) do
      if not ignore(file) then
         local name = file:basename()
         if #file:extension() > 1 then
            name = string.sub(name, 1, - #file:extension() - 1)
         end
         if name == basename then
            s:verb(\"  ~ \" .. name)
            deck.eponym = file
         end
      end
   end

   s:verb(\"#deck is : \" .. #deck)
   return codex
end"]
// END RANK codeblock_101

section_102 -> { header_118 prose_119 codeblock_120 codeblock_121 codeblock_122}
{rank=same; header_118 prose_119 codeblock_120 codeblock_121 codeblock_122}

header_118 [label="3 : __tostring"]

prose_119 [label="prose"]

codeblock_120 [label="code block 186-190"]

codeblock_121 [label="code block 192-212"]

codeblock_122 [label="code block 215-218"]


// END RANK section_102

header_118 -> leaf_123
leaf_123  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** __tostring"]
// END RANK header_118

prose_119 -> { raw_124}
{rank=same; raw_124}

raw_124 [label="raw"]


// END RANK prose_119

raw_124 -> leaf_125
leaf_125  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_124

codeblock_120 -> leaf_126
leaf_126  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Deck.__tostring(deck)
   return deck.dir.path.str
end"]
// END RANK codeblock_120

codeblock_121 -> leaf_127
leaf_127  [color=Gray,shape=rectangle,fontname=Inconsolata,label="new = function (codex, dir)
   if type(dir) == \"string\" then
      dir = Dir(dir)
   end
   if __Decks[dir] then
      return __Decks[dir]
   end
   local deck = setmetatable({}, Deck)
   deck.dir = dir
   deck.codex = codex
   deck.docs  = {}
   deck.srcs  = {}
   deck.docMds = {}
   deck.docDots = {}
   deck.docSvgs = {}
   -- deck.docHTMLs = {} #todo
   Deck.case(deck)
   return deck
end"]
// END RANK codeblock_121

codeblock_122 -> leaf_128
leaf_128  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Deck.idEst = new
return new"]
// END RANK codeblock_122


}
