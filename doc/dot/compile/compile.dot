digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 161"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-148"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 codeblock_6 section_7 section_8 section_9 section_10}
{rank=same; header_2 prose_3 prose_4 prose_5 codeblock_6 section_7 section_8 section_9 section_10}

header_2 [label="1 : Compile"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

codeblock_6 [label="code block 12-19"]

section_7 [label="section: 21-59"]

section_8 [label="section: 60-99"]

section_9 [label="section: 100-148"]

section_10 [label="section: 149-161"]


// END RANK section_1

header_2 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Compile"]
// END RANK header_2

prose_3 -> { raw_12 prespace_13 literal_14 raw_15}
{rank=same; raw_12 prespace_13 literal_14 raw_15}

raw_12 [label="raw"]

prespace_13 [label="prespace"]

literal_14 [label="literal"]

raw_15 [label="raw"]


// END RANK prose_3

raw_12 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


The goal here is to make a single SQLite file containing all bytecode for"]
// END RANK raw_12

prespace_13 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_13

literal_14 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="bridge"]
// END RANK literal_14

raw_15 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" projects.
"]
// END RANK raw_15

prose_4 -> { raw_20}
{rank=same; raw_20}

raw_20 [label="raw"]


// END RANK prose_4

raw_20 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Eventually this can drive a general-purpose build system I guess. We've got
a long way to go with Orb before that's practical.
"]
// END RANK raw_20

prose_5 -> { raw_22}
{rank=same; raw_22}

raw_22 [label="raw"]


// END RANK prose_5

raw_22 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
For now it just makes LuaJIT bytecode.
"]
// END RANK raw_22

codeblock_6 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local loader = require \"compile/loader\"

local sha = require \"compile/sha3\" . sha512

local s = require \"status\" ()
s.verbose = false"]
// END RANK codeblock_6

section_7 -> { header_25 prose_26 structure_27 prose_28 prose_29 codeblock_30}
{rank=same; header_25 prose_26 structure_27 prose_28 prose_29 codeblock_30}

header_25 [label="4 : splice(tab, index, into)"]

prose_26 [label="prose"]

structure_27 [label="structure"]

prose_28 [label="prose"]

prose_29 [label="prose"]

codeblock_30 [label="code block 34-57"]


// END RANK section_7

header_25 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** splice(tab, index, into)"]
// END RANK header_25

prose_26 -> { raw_32 prespace_33 literal_34 raw_35}
{rank=same; raw_32 prespace_33 literal_34 raw_35}

raw_32 [label="raw"]

prespace_33 [label="prespace"]

literal_34 [label="literal"]

raw_35 [label="raw"]


// END RANK prose_26

raw_32 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is borrowed from"]
// END RANK raw_32

prespace_33 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_33

literal_34 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="femto.core"]
// END RANK literal_34

raw_35 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and should be replaced with it once I'm
finally done sorting everything into a database
"]
// END RANK raw_35

structure_27 -> { hashline_40}
{rank=same; hashline_40}

hashline_40 [label="hashline"]


// END RANK structure_27

hashline_40 -> { hashtag_41}
{rank=same; hashtag_41}

hashtag_41 [label="hashtag"]


// END RANK hashline_40

hashtag_41 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="todo"]
// END RANK hashtag_41

prose_28 -> { raw_43}
{rank=same; raw_43}

raw_43 [label="raw"]


// END RANK prose_28

raw_43 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
compatible with existing functions and method syntax.
"]
// END RANK raw_43

prose_29 -> { raw_45 prespace_46 literal_47 raw_48 prespace_49 literal_50 raw_51 prespace_52 literal_53 raw_54}
{rank=same; raw_45 prespace_46 literal_47 raw_48 prespace_49 literal_50 raw_51 prespace_52 literal_53 raw_54}

raw_45 [label="raw"]

prespace_46 [label="prespace"]

literal_47 [label="literal"]

raw_48 [label="raw"]

prespace_49 [label="prespace"]

literal_50 [label="literal"]

raw_51 [label="raw"]

prespace_52 [label="prespace"]

literal_53 [label="literal"]

raw_54 [label="raw"]


// END RANK prose_29

raw_45 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
if"]
// END RANK raw_45

prespace_46 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_46

literal_47 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="index"]
// END RANK literal_47

raw_48 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is nil, the contents of"]
// END RANK raw_48

prespace_49 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_49

literal_50 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label="into"]
// END RANK literal_50

raw_51 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" will be inserted at the end of"]
// END RANK raw_51

prespace_52 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_52

literal_53 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="tab"]
// END RANK literal_53

raw_54 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_54

codeblock_30 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local insert = table.insert

local sp_er = \"table<core>.splice: \"
local _e_1 = sp_er .. \"$1 must be a table\"
local _e_2 = sp_er .. \"$2 must be a number\"
local _e_3 = sp_er .. \"$3 must be a table\"

local function splice(tab, idx, into)
   assert(type(tab) == \"table\", _e_1)
   assert(type(idx) == \"number\" or idx == nil, _e_2)
   if idx == nil then
      idx = #tab + 1
   end
   assert(type(into) == \"table\", _e_3)
    idx = idx - 1
    local i = 1
    for j = 1, #into do
        insert(tab,i+idx,into[j])
        i = i + 1
    end
    return tab
end"]
// END RANK codeblock_30

section_8 -> { header_66 prose_67 prose_68 prose_69 prose_70 codeblock_71}
{rank=same; header_66 prose_67 prose_68 prose_69 prose_70 codeblock_71}

header_66 [label="4 : _moduleName(path, project)"]

prose_67 [label="prose"]

prose_68 [label="prose"]

prose_69 [label="prose"]

prose_70 [label="prose"]

codeblock_71 [label="code block 73-97"]


// END RANK section_8

header_66 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** _moduleName(path, project)"]
// END RANK header_66

prose_67 -> { raw_73}
{rank=same; raw_73}

raw_73 [label="raw"]


// END RANK prose_67

raw_73 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This takes a Path and a string for the project and derives a plausible module
name from it.
"]
// END RANK raw_73

prose_68 -> { raw_75}
{rank=same; raw_75}

raw_75 [label="raw"]


// END RANK prose_68

raw_75 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This encodes certain assumptions which I would like to loosen, later.
"]
// END RANK raw_75

prose_69 -> { raw_77}
{rank=same; raw_77}

raw_77 [label="raw"]


// END RANK prose_69

raw_77 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Every time I work with directories I'm reminded what an awkward way to
organize information they are.  Yet here we are...
"]
// END RANK raw_77

prose_70 -> { raw_79 prespace_80 literal_81 raw_82}
{rank=same; raw_79 prespace_80 literal_81 raw_82}

raw_79 [label="raw"]

prespace_80 [label="prespace"]

literal_81 [label="literal"]

raw_82 [label="raw"]


// END RANK prose_70

raw_79 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- [ ] #Todo  Some paths aren't modules, like"]
// END RANK raw_79

prespace_80 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_80

literal_81 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".DS_Store"]
// END RANK literal_81

raw_82 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".  We need to not make
             a module under those conditions.
"]
// END RANK raw_82

codeblock_71 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function _moduleName(path, project)
   local mod = {}
   local inMod = false
   for i, v in ipairs(path) do
      if v == project then
         inMod = true
      end
      if inMod then
         if i ~= #path then
            table.insert(mod, v)
          else
             table.insert(mod, path:barename())
         end
      end
   end
   -- drop the bits of the path we won't need
   --- awful kludge fix
   local weird_path = table.concat(mod)
   local good_path = string.gsub(weird_path, \"%.%_\", \"\")
   local _, cutpoint = string.find(good_path, \"/src/\")
   local good_path = string.sub(good_path, cutpoint + 1)
   return good_path
end"]
// END RANK codeblock_71

section_9 -> { header_88 prose_89 prose_90 codeblock_91}
{rank=same; header_88 prose_89 prose_90 codeblock_91}

header_88 [label="3 : compileDeck(deck)"]

prose_89 [label="prose"]

prose_90 [label="prose"]

codeblock_91 [label="code block 107-146"]


// END RANK section_9

header_88 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** compileDeck(deck)"]
// END RANK header_88

prose_89 -> { raw_93}
{rank=same; raw_93}

raw_93 [label="raw"]


// END RANK prose_89

raw_93 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Compiles a deck to bytecode. The deck must be knitted first.
"]
// END RANK raw_93

prose_90 -> { raw_95 prespace_96 literal_97 raw_98 prespace_99 literal_100 raw_101}
{rank=same; raw_95 prespace_96 literal_97 raw_98 prespace_99 literal_100 raw_101}

raw_95 [label="raw"]

prespace_96 [label="prespace"]

literal_97 [label="literal"]

raw_98 [label="raw"]

prespace_99 [label="prespace"]

literal_100 [label="literal"]

raw_101 [label="raw"]


// END RANK prose_90

raw_95 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Returns ("]
// END RANK raw_95

prespace_96 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_96

literal_97 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label="true"]
// END RANK literal_97

raw_98 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", or"]
// END RANK raw_98

prespace_99 -> leaf_106
leaf_106  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_99

literal_100 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label="false"]
// END RANK literal_100

raw_101 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" ), the number of errors, and an array of strings
representing all files which didn't compile.
"]
// END RANK raw_101

codeblock_91 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Compile = {}
local dump = string.dump

local function compileDeck(deck)
   local codex = deck.codex
   s:verb (\"codex project is \" .. codex.project)
   local complete, errnum, errs = true, 0, {}
   deck.bytecodes = deck.bytecodes or {}
   for _, subdeck in ipairs(deck) do
      local deck_complete, deck_errnum, deck_errs = compileDeck(subdeck)
      complete = complete and deck_complete
      errnum = errnum + deck_errnum
      splice(errs, nil, deck_errs)
   end
   for name, src in pairs(deck.srcs) do
      local bytecode, err = load (tostring(src),
                                  \"@\" .. _moduleName(name, codex.project))
      if bytecode then
         -- add to srcs
         local byte_str = dump(bytecode)
         local byte_table = {binary = byte_str}
         byte_table.hash = sha(byte_str)
         byte_table.name = _moduleName(name, codex.project)
         codex.bytecodes[name] = byte_table
         deck.bytecodes[name] = byte_table
         s:verb(\"compiled: \" .. codex.project .. \":\" .. byte_table.name)
      else
         s:verb \"error:\"
         s:verb(err)
         complete = false
         errnum = errnum + 1
         errs[#errs + 1] = tostring(name)
      end
   end
   return complete, errnum, errs
end

Compile.compileDeck = compileDeck"]
// END RANK codeblock_91

section_10 -> { header_110 prose_111 codeblock_112 codeblock_113}
{rank=same; header_110 prose_111 codeblock_112 codeblock_113}

header_110 [label="3 : Compile.compileCodex(codex)"]

prose_111 [label="prose"]

codeblock_112 [label="code block 151-157"]

codeblock_113 [label="code block 159-161"]


// END RANK section_10

header_110 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Compile.compileCodex(codex)"]
// END RANK header_110

prose_111 -> { raw_115}
{rank=same; raw_115}

raw_115 [label="raw"]


// END RANK prose_111

raw_115 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_115

codeblock_112 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Compile.compileCodex(codex)
   local complete, errnum, errs = compileDeck(codex.orb)
   loader.commitCodex(loader.open(), codex):close()
   return complete, errnum, errs
end"]
// END RANK codeblock_112

codeblock_113 -> leaf_118
leaf_118  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return Compile"]
// END RANK codeblock_113


}
