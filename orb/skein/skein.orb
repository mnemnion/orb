* Skein


  A skein is an object for holding a Doc, with all its derivative works.

The first toolchain was a bootstrap, which was accomplished by the simple
expedient of perfect uniformity.  Every file in the =orb= directory of a
project was presumed to have some Lua in it, and there is a one-to-one
correspondence between =orb= on the one hand, and =src= on the other, same
for the weave.  Every line of Lua is found in the same place as it is in the
Orb file, and so on.

This was a useful paradigm, but now we have the new parser, and we need to
walk back some of those design choices.  The Orb files must remain the source
of truth, but everything else changes: Orb files may affect each other,
mutate each other both in ways which are written to disk and ways which are
not, and may generate multiple artifacts of the same sort, or one Orb document
may be a source of code in a knit or weave derived ultimately from another.

We took this general-to-specific approach to the extreme where compilation in
the old method is all-or-nothing.  We briefly had the ability to knit (but not
weave) a single document, but surrendered it.

Now we'll build from a single file outward.  We keep the semi-literate style
for now, but make a single skein capable of everything that needs: parsing,
formatting, spinning, knitting, weaving, and writing all changes to both the
filesystem and the module database.

Then we'll rebuild the Codex, with as few of the old assumptions as possible.
In particular, we'll leave out Decks at first, and add them back if they
actually prove useful, which they might.  That gets us to feature-parity with
the old compiler, which we may then remove.

With careful engineering, this will put us in a position for Docs to be
dependent on other Docs, which we can resolve with inter-skein communication.


** Instance fields

These are successively created and manipulated over the course of actions
taken on the skein.

- codex:  A skein carrys a reference to its enclosing codex, which is
          necessary to enable more complex kinds of inter-document activity.

          #Todo this might not actually be necessary; determine.

- source:  The artifacts of the source file:

  - path:  The Path of the original document.

  - text:  String representing the contents of the document file.

  - doc:  The Doc node corresponding to the parsed source doc.

  - modified:  #NYI, a flag to mark if the source document itself has been
               modified and needs to be written to disk.

- knitted:  The artifacts produced by knitting the source.  Currently, this is
            a key-value map, where the key is the =code_type= field and the
            value is a Scroll.

- woven:  The artifacts produced by weaving the source.  #NYI.

- bytecode:  Perhaps a misnomer; this is best defined as artifacts produced by
             further compilation of the knit, suitable for writing to the
             modules database or otherwise using in executable form.

             For the core bridge modules, this is LuaJIT bytecode, but in
             other cases it could be object code, or a .jar file, minified JS,
             and the like.

- completions:  #NYI.  These are closures with the necessary information to
                provide the parameters needed to complete them. An example
                would be a transclusion or macroexpansion which draws from a
                namespace that isn't in the source file.

                This is the only approach which generalizes across projects,
                and across compilation scenarios:  We want, at the limit, to
                be able to process a single source file, while opening and
                processing only those additional files needed to complete its
                cycle.


**** imports

#!lua
local File = require "fs:fs/file"
local Path = require "fs:fs/path"
local Doc  = require "orb:orb/doc"
local knitter = require "orb:knit/newknit" ()
#/lua

#!lua
local Skein = {}
Skein.__index = Skein
#/lua


** Methods

  Skeins are in the chaining style: all methods return the skein at the bottom.
If additional return values become necessary, they may be supplied after.

Generally, the state created and manipulated by method calls is attached to
the skein itself.

Methods are listed in the order in which they are expected to be executed.
Some (knit and weave, notably) will probably function correctly in another
order, while others will not; certainly we can't process anything without
loading it in some fashion.

We may offer an affordance for working outside the filesystem, but we surely
don't need it now.


*** Skein:load()

This loads the Path data into the =skein.source.text= field.

If called inside a coroutine and uv even loop, this uses a callback, allowing
us to employ the threadpool for parallelizing the syscall and read penalty.

#!lua
function Skein.load(skein)
   skein.source.text = skein.source.file:read()
   return skein
end
#/lua


*** Skein:filter()

Optional step which mostly replaces tabs in the non-codeblock portions of the
text.  Any changes will flip the =modified= flag.

Currently a no-op.


#!lua
function Skein.filter(skein)
   return skein
end
#/lua


*** Skein:spin()

This spins the textual source into a parsed document.

It will eventually perform some amount of post-processing as well, such as
in-place expansion of notebook-style live documents.

#!lua
function Skein.spin(skein)
   skein.source.doc = Doc(skein.source.text)
   return skein
end
#/lua


*** Skein:format()

#NYI, this will perform formatting inside the Orb portion of documents.

#!lua
function Skein.format(skein)
   return skein
end
#/lua


*** Skein:knit()

Produces sorcery, derived 'source code' in the more usual sense.

Referred to as a 'tangle' in the traditional literate coding style.

#!lua
function Skein.knit(skein)
   knitter:knit(skein)
   return skein
end
#/lua


*** Skein:weave()

#NYI

This produces derived human-readable documents from the source.

Our current pipeline for this is sadly neglected and produces passable
Git-Flavored Markdown, with little attention paid to edge cases.

The roadmap will favor HTML as the first-class output format.

This will probably take parameters to specify subcategories of possible
documents; by default, it will produce all the rendered formats it is capable
of producing.

#!lua
function Skein.weave(skein)
   return skein
end
#/lua


*** Skein:commit(stmts)

This commits modules to the database, provided with a collection of prepared
statements sufficient to complete the operation.

We might fold the compilation step into this, we might not, haven't decided.

#!lua
function Skein.commit(skein, stmts)
   return skein
end
#/lua


*** Skein:persist()

Writes derived documents out to the appropriate areas of the filesystem.

#!lua
function Skein.persist(skein)
   return skein
end
#/lua


*** new(path, codex)

Takes a path to the source document, which may be either a Path or a bare
string.

Also receives the handle of the enclosing codex, which we aren't using yet,
and might not need.

#!lua
local function new(path, codex)
   local skein = setmetatable({}, Skein)
   skein.source = {}
   if codex then
      skein.codex = codex
      -- lift info off the codex here
      skein.project     = codex.project
      -- this should just be codex.orb but I turned that into a Deck for some
      -- silly reason
      skein.source_base = codex.orb_base
      skein.knit_base   = codex.src
      skein.weave_base  = codex.doc
      -- #todo we're including the Dirs here, when what we're likely to need
      -- is the Path, is this wise?  It's easy to reach the latter...
   end
   skein.source.file = File(Path(path):absPath())
   return skein
end

Skein.idEst = new
#/lua


#!lua
return new
#/lua