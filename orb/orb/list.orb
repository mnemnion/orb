* List


  A subgrammar for lists, which orders them arcically.


*** Structure

The list and listline rules are concerned with capturing a full list, which is
mainly a matter of detecting indentations and recognizing the lead sequences
which produce a new line.  There is a listline subrule to handle the details
of parsing within a list line.

This gives us a flat structure, for which we calculate the indentation of each
line; but for various operations, we want an arcical structure, a tree.

The question is, which structure? For a list like this:

#!orb
-  A list item
-  A sublist:
   -  a
   -  b
#/orb

We could represent this as =={List = {Line, Line, List = {Line, Line}}}==, but
the second top-level line is properly associated with the sub-list.  Various
operations we will perform depend on this, and we don't want to have to
extract it from context.

So the List metatable will post-process so that the Node looks like this:

#!orb
-  list
  -  list_line
  -  list
    -  lead
      -  list_line
    -  list_line
    -  list_line
#/orb

This means that the top-level has only two items, not three, and the bottom
level has three items, but one is 'special', so it has two ordinary items,
which is basically correct.


*** Implementation

  This one is a bit trickier than folding sections, but it's the same basic
operation.

Each deeper level of indentation belongs to the next-lowest section which is
above it in the heirarchy.

All of the list lines start under the top list, and all but the first run of
top-level list lines get moved, followed by =compact=ing the top list.

The Doc case is simpler, because we aren't creating anything.  Everything at
the top level is either a block, or a Section with no Section above it:
usually, but not inevitably, a =*= Section.

For Lists, we do have to create a new List out of the List-line *before* a
deeper List-line, replace it with that List, and then put subsequent
List-Lines underneath it.

Doesn't really change anything, we end up with the top-level List having holes
in it and =compact= will fix those, while the sub-Lists are all created on the
fly and don't require further attention.


**** imports

#!lua
local Twig = require "orb:orb/metas/twig"
local table = require "core:core/table"

local s = require "status:status" ()
s.verbose = true
#/lua


** List Metatable

#!lua
local List = Twig :inherit 'list'
#/lua


*** Post-processing

#!lua
local function _parent(list, dent)
   local parent;
   repeat
      parent = list.parent
   until parent.indent == dent
   return parent
end
#/lua

#!lua
local function _makesublist(line)
   local sublist = { first = line.first,
                     last = line.last,
                     str = line.str }
   local lead = { first = line.first,
                  last = line.last,
                  parent = sublist,
                  str = line.str,
                  id = 'lead' }
   setmetatable(lead, Twig)
   sublist[1] = lead
   lead[1] =  line
   line.parent = lead
   return setmetatable(sublist, List)
end
#/lua

#!lua
local insert, compact = assert(table.insert), assert(table.compact)

local function _insert(list, list_line)
   insert(list, list_line)
   list_line.parent = list
   list.last = list_line.last
end

local function post(list)
   local top = #list
   local base = list[1].indent -- always 2 by the grammar but that could change
   -- add an indent to the list itself

   list.indent = base
   -- tracking variables:
   local dent = base
   local work_list = list
   for i = 1, top do
      -- is it an indent line?
      if not list[i].indent then
         local id, line, col = list[i].id, list[i]:linePos()
         s:verb("no indent on %s at line %d, col %d", id, line, col)
      end
      if list[i].indent > dent then
         -- handle base list a bit differently
         if work_list == list then
            -- make a list from the previous line
            local sublist = _makesublist(list[i - 1])
            sublist.parent = list
            dent = list[i].indent
            sublist.indent = dent
            -- insert working line
            _insert(sublist, list[i])
            -- replace prior line with list
            list[i - 1] = sublist
            -- nil out working line
            list[i] = nil
            -- replace the work list
            work_list = sublist
         else
            local sublist = _makesublist(work_list[#work_list])
            sublist.parent = work_list
            dent = list[i].indent
            sublist.indent = dent
            _insert(sublist, list[i])
            list[i] = nil
            work_list = sublist
         end
      elseif dent > base and dent == list[i].indent then
         -- put it in the worklist
         _insert(work_list, list[i])
         list[i] = nil
      elseif dent < list[i].indent then
         -- get a new work_list
         work_list = _parent(work_list, list[i].indent)
         _insert(work_list, list[i])
         dent = list[i].indent
         list[i] = nil
      end -- otherwise we have a list_line we can leave in place
   end
   compact(list, top)
   return list
end
#/lua


*** List Function

  We could make a subgrammar and use this as a proper post function, but
there's not a lot of point in doing so, since we don't have additional grammar
to match.

So this is just a function which performs the folding on the list and returns
it.

#!lua
local function List_fn(list, offset)
   setmetatable(list, List)
   return post(list)
end
#/lua


local function List_fn(list, offset)
   setmetatable(list, List)
   if _Bridge.testing then
      return post(list)
   else
      return list
   end
end

#!lua
return List_fn
#/lua
