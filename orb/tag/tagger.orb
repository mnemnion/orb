* Tagger


  The tagger implements the Orb tag engine.

This receives a Skein, and walks the enclosed Doc, finding tags (hashtags and
handles), and assigning them to a tag map attached to the Skein.

This ends up being a pretty gnarly algorithm, since the relationship between
where a tag is, and what it refers to, is non-trivial.  But we need to
establish this relationship in order to do all of the interesting things which
Orb is designed to do.

It's cleaner, as a matter of implementation, to do this in a single pass,
rather than to handle tag assignment if and only if we end up needing it.  It
will be possible to push this out to the edge if necessary, which I expect it
won't be.


**** imports

#!lua
local Set = require "set:set"
local Annotate = require "status:annotate"
#/lua


**** Taggable categories

These are the parents of a tag which can receive tags.

#!lua
local taggable = Set {
   'section',
   'header',
   'list_line',
   'numlist_line',
   'codeblock',
   'blockquote',
   'handle_line',
   'hashtag_line',
   'table',
   'drawer',
}
#/lua


** Tagger

Implements the actual tagging mechanism.

#!lua
local sub, lower = assert(string.sub), assert(string.lower)
local insert = assert(table.insert)
#/lua


*** _taggableParent(node, doc)

Returns the parent of the tag Node which is "taggable".

Also passed the Doc, to facilitate checking for root.  This could also be
done with node.parent == node, but this is more robust, and we have the Doc
handy.

#!lua
local function _taggableParent(node, doc)
   local parent = node.parent
   while parent ~= doc do
      if taggable :âˆˆ (parent.id) then
         break
      end
      parent = parent.parent
   end
   return parent
end
#/lua


*** _capitalTag(tag)

Receives the text of the tag, checking it for initial capitalization.

If capitalized, returns =true= and the minimized version of the tag, if not,
=false= and the original tag text.

#!lua
local function _capitalTag(tag)
   local first = sub(tag, 1, 1)
   if lower(first) == first then
      return false, tag
   else
      return true, lower(first) .. sub(tag, 2)
   end
end
#/lua

*** _tagUp(tags, tag, node)

We make a map of tag-to-node, and node-to-tag.

#!lua
local function _tagUp(tags, node, tag, note)
   note("tagging a %s on line %d with %s", node.id, (node:linePos()), tag)
   tags[tag] = tags[tag] or {}
   insert(tags[tag], node)
   tags[node] = tags[node] or {}
   tags[node][tag] = true
end
#/lua


**** _capTagResolve[id](tags, parent, tag, note)

A table of functions which resolve a capital tag, based on the type of parent.

#!lua
local _capTagResolve = {
   list_line = function(tags, list_line, tag, note)
      if list_line.parent.id ~= 'lead' then
         -- no children on a list line, just apply the tag
         _tagUp(tags, list_line, tag, note)
         return
      end
      local list = list_line.parent.parent
      local function _tagChildren(l)
         note("tagging children of list on line %d", list_line:linePos())
         for _, child in ipairs(l) do
            if child.id == 'lead' then
               -- tag the list_line
               _tagUp(tags, child[1], tag, note)
            elseif child.id == 'list_line' or child.id == 'numlist_line' then
               _tagUp(tags, child, tag, note)
            elseif child.id == 'list' then
               _tagChildren(child)
            else
               note("encountered a strange child: %s", child.id)
            end
         end
      end
      _tagChildren(list)
   end,

}

-- numlist_lines use the list_line logic
_capTagResolve.numlist_line = _capTagResolve.list_line
#/lua

#!lua
local function Tagger(skein)
   local note = skein.note or Annotate()
   skein.note = note
   local doc = assert(skein.source.doc, "No doc found on Skein")
   local tags = {}
   skein.tags = tags
   for node in doc:walk() do
      if node.id == 'hashtag' then
         -- this is where all the gnarly stuff happens
         -- for now, add the node itself to the tag collection
         local tagspan = sub(node.str, node.first + 1, node.last)
         local tag_parent = _taggableParent(node, doc)
         local iscap, tag = _capitalTag(tagspan)
         if iscap then
            note("capital tag %s on %s, made into %s",
                  tagspan, tag_parent.id, tag)
            _capTagResolve[tag_parent.id](tags, tag_parent, tag, note)
         else
            note("miniscule tag %s on %s", tag, tag_parent.id)
            _tagUp(tags, tag_parent, tag, note)
         end
      end
   end

   return skein
end
#/lua

#!lua
return function(skein)
   local ok, res = pcall(Tagger, skein)
   if ok then return skein end
   skein.note("error: %s", res)
   return skein
end
#/lua
