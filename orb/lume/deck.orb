* Deck


  A Deck is a meta-directory, cross referenced between source, sorcery, and
weaves.

#!lua
local s   = require "status:status" ()
s.verbose = false
s.chatty  = true

local c   = require "singletons/color"
local cAlert = c.color.alert

local Dir = require "fs:directory"
#/lua


#!lua
local Deck = {}
Deck.__index = Deck
local __Decks = {}
#/lua

#!lua
-- ignore a few critters that can show up
local decIgnore = {".DS_Store", ".git"}

local function ignore(file)
   local willIgnore = false
   local basename = file:basename()
   for _, str in ipairs(decIgnore) do
      willIgnore = willIgnore or basename == str
   end
   -- Goddammit Dropbox
   willIgnore = willIgnore or (string.find(tostring(file), "%.%_") ~= nil)
   return willIgnore
end
#/lua

** case(deck)

  Casing is what we call gathering information about a deck, its subdecks,
and associated files.

Casing a deck will cause its subdecks to be cased also, recursively. This is
where we will add inode comparison to keep from following cyclic references,
since it's what draws directory attributes out of the filesystem into memory.

After casing a Deck is ready to be [[spun][httk://]].

#!lua
local new

function Deck.case(deck)
   s:verb("dir: " .. tostring(deck.dir))
   local dir = deck.dir
   local codex = deck.lume
   local basename = dir:basename()
   assert(dir.idEst == Dir, "dir not a directory")
   local lumeRoot = lume.root:basename()
   s:verb("root: " .. tostring(lume.root) .. " base: " ..tostring(lumeRoot))
   local subdirs = dir:getsubdirs()
   s:verb("  " .. "# subdirs: " .. #subdirs)
   for i, sub in ipairs(subdirs) do
      s:verb("  - " .. sub.path.str)
      deck[i] = new(lume, sub)
   end
   local files = dir:getfiles()
   s:verb("  " .. "# files: " .. #files)
   for i, file in ipairs(files) do
      if not ignore(file) then
         local name = file:basename()
         if #file:extension() > 1 then
            name = string.sub(name, 1, - #file:extension() - 1)
         end
         if name == basename then
            s:verb("  ~ " .. name)
            deck.eponym = file
         end
      end
   end

   s:verb("#deck is : " .. #deck)
   return lume
end
#/lua