* File


An async file abstraction using libuv primitives.

Tim Caswell sent me a small piece of example code for how to use callbacks in
a coroutine-compliant way to get asynchronous behavior, which looked like
this:

*** Tim Caswell's Magnificent Example

This comes from an email exchange we had in 2018:

#!lua-example
local function sleep(ms, answer)
  local co = coroutine.running()
  local timer = uv.new_timer()
  timer:start(ms, 0, function ()
    timer:close()
    return coroutine.resume(co, answer)
  end)
  return coroutine.yield()
end

-- Using it would look like:

coroutine.wrap(function ()
  print "Getting answer to everything..."
  local answer = sleep(1000, 42)
  print("Answer is", answer)
end)()
#/lua-example

And we can expand this example so that the =sleep= function can be called
inside or outside a coroutine, adapting to be blocking or non-blocking,
respectively:

#!lua-example
local function sleep(ms, answer)
  local co, main = coroutine.running()
  if not main then
     local time = uv.new_timer()
     timer:start(ms, 0, function()
        timer:close()
        return coroutine.resume(co, answer)
     end)
     return coroutine.yield()
  else
     -- blocking sleep function _sleep not provided
     _sleep(ms)
     return(answer)
  end
end
#/lua-example

So our file abstraction should behave like this: wrapped in a coroutine, it
uses async-callback logic, and outside of one, it blocks.

[[example]
[https://github.com/luvit/luv/blob/master/examples/uvbook/uvcat.lua]] of
non-blocking (threadpool) uv_file code.


*** Goal

This should act as a drop-in replacement for =walk/file=.

Kinda.  Sorta.  I'm going to take the opportunity to rethink some of the
extraneous complexity of those classes.

But the core idea is that they yield if they're in a position to do so, and
otherwise will block.


**** imports

The Path abstraction is in need of an overhaul but we'll want to have one,
and the existing one is ehhhh good enough for government work.

#!lua
local uv = require "luv"
local Path = require "walk/path"
local running, resume, yield = assert(coroutine.running),
                               assert(coroutine.resume),
                               assert(coroutine.yield)
#/lua

#!lua
local File = {}
local _Files = setmetatable({}, {__mode = "v"})
#/lua

This isn't used anywhere, #Todo decide whether to remove it:
#!lua
function File.parentPath(file)
end
#/lua

/Also/ not used, but probably should be:
#!lua
function File.exists(file)
end
#/lua

This is used:
#!lua
function File.basename(file)
end
#/lua

So is this:
#!lua
function File.extension(file)
end
#/lua


*** File:read()

Opens a file, reads the contents, closes the file, and returns.

#!lua
function File.read(file)
   local co, main = running()
   if main or (not uv.loop_alive()) then
      local f = io.open(file.path.str, "r")
      if not f then
         return nil, "cannot open for read: " .. file.path.str
      end
      local content = f:read("*a")
      f:close()
      return content
   else
      -- 420 == tonumber('644', 8)
      local path = tostring(file.path)
      local stat, err = uv.fs_stat(path)
      if not stat then
         return resume(co, nil, "error opening file: " .. err)
      end
      uv.fs_open(file.path.str, "r", 420, function(err, fd)
         if err then
            return resume(co, nil, "error opening file: " .. err)
         end
         local stat = uv.fs_fstat(fd)
         local content = uv.fs_read(fd, stat.size, 0)
         uv.fs_close(fd)
         return resume(co, content)
      end)
      return yield()
   end
end
#/lua


*** File:write(doc)

This uses the blocking code if we're not in a uv event loop, and non-blocking
if we are; there's nothing to do after a call other than close, so an async
mode isn't really necessary here.

#!lua
local function _withMode(mode)
   return function (file, doc)
      if uv.loop_alive() then
         uv.fs_open(file.path.str, mode, 420, function(err, fd)
            if err then
               error("unable to open for write: " .. file.path.str)
            end
            uv.fs_write(fd, tostring(doc), -1, function()
               uv.fs_close(fd)
            end)
         end)
      else
         local f = io.open(file.path.str, mode)
         if not f then
            error("cannot open for write: " .. file.path.str)
         end
         f:write(tostring(doc))
         f:close()
      end
   end
end

File.write = _withMode "w"
File.append = _withMode "a"
#/lua


*** new(Path)

#!lua
local FileMeta = { __index = File }

local function new (file_path)
   local file_str = tostring(file_path)
   -- #nb this is a naive and frankly dangerous guarantee of uniqueness
   -- and is serving in place of something real since filesystems... yeah
   if _Files[file_str] then
      return _Files[file_str]
   end

   local file = setmetatable({}, FileMeta)
   if type(file_path) == "string" then
      file_path = Path(file_path)
   end
   if file_path.isDir then
      error("cannot make file: " .. file_path.str .. " is a directory")
   end
   file.path = file_path
   _Files[file_str] = file

   return file
end

File.idEst = new
#/lua

#!lua
return new
#/lua